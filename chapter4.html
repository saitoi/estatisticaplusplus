<!DOCTYPE html>
<html style="height: 100%;">
<head>
    <title>Capítulo 4: Depuração</title>
    <!-- Estilos pelo CSS -->
    <link rel="stylesheet" type="text/css" href="css/codigo.css">
    <link rel="stylesheet" type="text/css" href="css/texto.css">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <!-- Fim dos estilos -->
</head>
<body>
<h1>4. Depuração</h1>

<!-- Primeira Seção -->
<h2>4.1. Compilando para Depuração</h2>

<p>
Durante o desenvolvimento de software, a <strong>depuração</strong> ou <strong><i>debugging</i></strong> desempenha um papel fundamental na identificação e correção eficiente de erros no código. Ao compilar programas em C, existe uma prática recomendada para facilitar a depuração: a utilização da opção <code class="bash">-g</code> ao chamar o GCC. Essa opção instrui o compilador a incluir informações de depuração no executável gerado. Essas informações, como símbolos de função, variáveis locais e localizações de linha, permitem uma análise detalhada do código durante a depuração. Por exemplo, ao executar o programa em um depurador, é possível definir pontos de interrupção, inspecionar valores de variáveis e rastrear a execução do código passo a passo.
</p>

<p>
Abaixo está um exemplo de código que podemos usar para ilustrar como compilar programas em C para depuração:
</p>

<figure><pre><code class="c">int foo (int *p);

int main (void)
{
    int *p = 0;
    /* ponteiro nulo */
    return foo (p);
}

int foo (int *p)
{
    int y = *p;
    return y;
}</pre><figcaption class="arq">exemplo.c</figcaption></figure>

<p>
Nesse código, temos duas funções: <code class="hljs c">main</code> e <code class="hljs c">foo</code>. A função <code class="hljs c">main</code> inicializa um ponteiro <code class="hljs c">p</code> com o valor nulo (0) e, em seguida, chama a função <code class="hljs c">foo</code> passando esse ponteiro como argumento. A função <code class="hljs c">foo</code> recebe um ponteiro como parâmetro e tenta acessar o valor apontado por ele. No entanto, como <code class="hljs c">p</code> é nulo, essa operação resulta em um erro. Para compilar esse código com a opção de depuração, você pode usar o seguinte comando:
</p>

<figure><pre><code class="bash">
$ gcc -Wall -g exemplo.c -o exemplo</code></pre></figure>

<p>
Ao executá-lo, receberemos uma mensagem de erro, indicando que houve uma violação de segmentação, <code class="bash">segmentation fault</code>. Essa mensagem é exibida quando ocorre uma tentativa de acessar uma área da memória que não é permitida, como no caso em que o ponteiro <code class="hljs c">p</code> aponta para o valor nulo.
</p>

<figure><pre><code class="bash">$ ./exemplo
segmentation fault (core dumped)</code></pre></figure>

<p>
Vamos falar sobre o arquivo <b>core</b> mencionado na mensagem de erro. Ele é um arquivo de despejo de memória que pode ser gerado quando ocorre uma falha grave em um programa e contém informações sobre o estado da memória no momento da falha, sendo útil para analisar e depurar o problema. Nem todos os sistemas geram automaticamente o <b>core</b> por padrão. Se ele não for gerado, essa funcionalidade pode ser habilitada executando o comando abaixo, que define temporariamente o tamanho máximo do arquivo core como ilimitado, permitindo a geração do <b>core</b> em caso de falha no programa:
</p>

<figure><pre><code class="bash">$ ulimit -c unlimited</code></pre></figure>

<p>
É possível que, ainda assim, o arquivo <b>core</b> não seja gerado. Caso você utilize o Ubuntu ou algum de seus derivados, é possível que ao desativar o Apport, o programa que reporta erros no Ubuntu, resolva o problema. Isso pode ser feito com o seguinte comando:
</p>

<figure><pre><code class="bash">$ sudo service apport stop</code></pre></figure>

<p>
É importante ressaltar que, se o <b>core</b> não tiver sido gerado durante a primeira execução do programa, <b>core</b> terá que ser executado novamente.
</p>

<!-- Segunda Seção -->
<h2>4.2. Depurando Programas</h2>

<p>
Vamos agora usar o gdb para depurar o nosso executável ``exemplo''. Para isso, escrevemos o seguinte comando:
</p>

<figure><pre><code class="bash">$ gdb exemplo core
(...)
Core was generated by './exemplo'.
Program terminated with signal SIGSEGV, Segmentation fault.
    
warning: Section '.reg-xstate/17012' in core file too small.
#0  0x00005636c35b715b in foo (p=0x0) at exemplo.c:12
11        int y = *p;
(gdb)</code></pre></figure>

<p>
O GDB aponta a linha do código onde ocorreu a falha do programa. Nesse caso, o erro ocorreu quando o programa tentou desreferenciar o ponteiro <code class="hljs c">p</code>. Para entender melhor o motivo da falha, podemos examinar o valor de <code class="hljs c">p</code> com o comando <code class="bash">print</code>:
</p>

<figure><pre><code class="bash"> (gdb) print p
$1 = (int *) 0x0</code></pre></figure>

<p>
Como visto acima, o ponteiro <code class="hljs c">p</code> é nulo, explicando a falha ao tentarmos desreferenciá-lo. Para investigar a sequência de chamadas de funções que conduziu ao estado atual do programa, pode-se exibir um rastreamento de pilha com o comando <code class="bash">backtrace</code>:
</p>

<figure><pre><code class="bash">(gdb) backtrace
#0  0x000055661c11315b in foo (p=0x0) at exemplo.c:12
#1  0x000055661c113149 in main () at exemplo.c:7</code></pre></figure>

<p>
Outra funcionalidade importante do GDB é a capacidade de definir pontos de interrupção usando o comando <code class="bash">break</code>, permitindo a parada da execução do programa em pontos específicos. Tais pontos poder ser determinados para funções específicas, linhas ou lugares na memória. Vamos definir um ponto de interrupção no início da função <code class="hljs c">main</code>:
</p>

<figure><pre><code class="bash">(gdb) break main
Breakpoint 1 at 0x55661c113135: file exemplo.c, line 5.</code></pre></figure>

<p>
Agora, quando executarmos o programa no GDB, o programa irá parar assim que a função <code class="hljs c">main</code> for executada. Poderemos, então, avançar pela execução do programa passo a passo com o comando <code class="bash">step</code>, aprimorando a observação do comportamento do programa:
</p>

<figure><pre><code class="bash">(gdb) run
Starting program: exemplo
Breakpoint 1, main () at exemplo.c:5
5        int *p = 0;
(gdb) step
7        return foo(p);
(gdp) print p
$2 = (int *) 0x0    /* ponteiro nulo */
(gdb)</code></pre></figure>

<p>
As variáveis podem ser modificadas durante a depuração com o comando <code class="bash">set var</code>, o que é útil para testar diferentes cenários. Vamos continuar com o nosso exemplo e modificar os valores de <code class="hljs">p</code> e <code class="hljs c">*p</code>. Por fim, após modificarmos as variáveis, retomaremos a execução do programa com o comando <code class="bash">continue</code>:
</p>

<figure><pre><code class="bash">(gdb) set variable p = malloc(sizeof(int))
(gdb) print p
$3 = (int *) 0x5555555592a0
(gdb) set variable *p = 255
(gdb) print *p
$4 = 255
(gdb) continue
Continuing.
[Inferior 1 (process 17673) exited with code 0377]    /* 0377 base 8 = 255 base 10 */
(gdb)</code></pre></figure>

<p>
Em resumo, introduzimos o processo de depuração de programas em C usando o depurador GNU, GDB. Abrangemos os comandos essenciais, incluindo como iniciar o GDB, definir pontos de interrupção, inspecionar variáveis e alterar seus valores, bem como rastrear a sequência de chamadas de funções, técnicas vitais para entender e resolver os problemas que ocorrem durante a execução do seu código.
</p>

</body>
</html>
